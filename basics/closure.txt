A Closure is one of the most powerful and fundamental concepts in JavaScript.
Let‚Äôs understand it in the simplest way possible.

‚úÖ Closure (Simple Definition)
A closure is created when an inner function remembers and can access variables from its outer function, even after the outer function has returned.

In short:
Function + its Lexical Environment = Closure

üß† Example (Very Easy)
function outer() {
  let count = 0;
  function inner() {
    count++;
    console.log(count);
  }
  return inner;
}

const fn = outer();  // outer() finished
fn(); // 1
fn(); // 2
fn(); // 3

üéâ Why does this work?
outer() is finished
normally count should be gone

BUT inner() remembers count
That memory is the closure


üìé Real-Life Analogy

Imagine you leave office but still have a key card that lets you enter.
Even though you're outside the building, you still have access.

Building = outer()

Key card = closure

You = inner function

üî• Another Example (Explains Lexical Scope + Closure)
function makeAdder(x) {
  return function (y) {
    return x + y;
  };
}

const add10 = makeAdder(10);  
console.log(add10(5)); // 15


add10 remembers x = 10 even though makeAdder is finished.

üì¶ Example: Private Variables Using Closure
function createCounter() {
  let count = 0;

  return {
    inc: () => ++count,
    dec: () => --count,
    get: () => count
  };
}

const counter = createCounter();

console.log(counter.inc()); // 1
console.log(counter.inc()); // 2
console.log(counter.get()); // 2


count is private ‚Äî only accessible via these functions.

‚≠ê One-Line Definition
Closure is when a function remembers the variables from its outer scope even after the outer function has finished executing.